<!doctype html>
<html lang="hu">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ir√°nyok j√°t√©k - 4x4 - 3 l√©p√©ses feladat</title>
  <style>
    :root{
      --gap: 10px;
      --cell: 86px;
      --radius: 12px;
      --bg: #0b1020;
      --line: rgba(255,255,255,.14);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.72);
      --ok: rgba(92, 255, 156, .35);
      --bad: rgba(255, 92, 92, .35);
    }

    *{ box-sizing: border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background: radial-gradient(1200px 600px at 30% 0%, #16224a 0%, var(--bg) 55%);
      color: var(--text);
    }

    .app{
      min-height: 100vh;
      display:flex;
      flex-direction: column;
      padding: 14px;
      gap: 12px;
    }

    .topbar{
      display:flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      background: rgba(255,255,255,.06);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding: 12px 12px;
    }

    .title{ font-weight: 700; letter-spacing: .2px; }

    .task{
      display:flex;
      flex-direction: column;
      gap: 4px;
      min-width: 260px;
      flex: 1;
    }
    .task strong{ font-size: 16px; }
    .task small{ color: var(--muted); line-height: 1.2; }

    .controls{
      display:flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    button{
      appearance:none;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.08);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      font-weight: 650;
      font-size: 14px;
      cursor: pointer;
      user-select: none;
      touch-action: manipulation;
    }
    button:active{ transform: translateY(1px); }

    .stage{
      display:flex;
      flex-direction: column;
      gap: 12px;
      align-items: center;
    }

    .card{
      width: min(560px, 96vw);
      background: rgba(255,255,255,.06);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding: 12px;
    }

    .gridWrap{
      display:flex;
      justify-content: center;
      align-items: center;
    }

    .grid{
      display:grid;
      grid-template-columns: repeat(4, var(--cell));
      grid-template-rows: repeat(4, var(--cell));
      gap: var(--gap);
      padding: var(--gap);
      border-radius: 16px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.16);
      touch-action: none;
      user-select: none;
      position: relative;
    }

    .cell{
      width: var(--cell);
      height: var(--cell);
      border-radius: 14px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      position: relative;
    }

    .cell.ok{ outline: 4px solid var(--ok); }
    .cell.bad{ outline: 4px solid var(--bad); }

    .piece{
      width: calc(var(--cell) - 10px);
      height: calc(var(--cell) - 10px);
      border-radius: 16px;
      display:flex;
      align-items: center;
      justify-content: center;
      font-size: 42px;
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.18);
      box-shadow: 0 10px 22px rgba(0,0,0,.32);
      position: absolute;
      left: 5px;
      top: 5px;
      touch-action: none;
      user-select: none;
    }

    .piece.fixed{
      background: rgba(255,255,255,.08);
      box-shadow: none;
      border-style: dashed;
      opacity: .95;
    }

    .piece.dragging{
      transform: scale(1.06);
      z-index: 9999;
    }

    .trayTitle{
      font-weight: 700;
      color: var(--muted);
      margin-bottom: 8px;
    }

    .trayHint{
      color: var(--muted);
      font-size: 13px;
      line-height: 1.25;
      margin-bottom: 10px;
    }

    .tray{
      display:flex;
      gap: 10px;
      padding: 10px;
      border-radius: 14px;
      border: 1px dashed rgba(255,255,255,.18);
      background: rgba(0,0,0,.12);
      justify-content: center;
      flex-wrap: wrap;
    }

    .traySlot{
      width: 92px;
      height: 92px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      display:flex;
      align-items: center;
      justify-content:center;
      position: relative;
    }

    .traySlot .piece{
      position: static;
      width: 82px;
      height: 82px;
      font-size: 46px;
    }

    .status{
      font-weight: 800;
      min-height: 24px;
      margin-top: 10px;
      text-align: center;
    }
    .status.ok{ color: rgba(160,255,200,.95); }
    .status.bad{ color: rgba(255,160,160,.95); }
    .status.neutral{ color: var(--muted); }

    .progress{
      margin-top: 6px;
      text-align: center;
      color: var(--muted);
      font-weight: 700;
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="topbar">
      <div class="task">
        <div class="title">Ir√°nyok gyakorl√°sa (4√ó4) ‚Äì 3 l√©p√©ses feladat</div>
        <strong id="taskText">Nyomd meg az ‚Äú√öj feladat‚Äù gombot.</strong>
        <small id="taskSub">A besz√©d lej√°tsz√°s√°hoz az els≈ë gombnyom√°s ut√°n a b√∂ng√©sz≈ë enged√©lyezi a hangot.</small>
      </div>
      <div class="controls">
        <button id="btnNew">√öj feladat</button>
        <button id="btnRepeat">Ism√©teld a hangot</button>
      </div>
    </div>

    <div class="stage">
      <div class="card">
        <div class="gridWrap">
          <div id="grid" class="grid" aria-label="4x4 r√°cs"></div>
        </div>
      </div>

      <div class="card">
        <div class="trayTitle">√Ållatok (h√∫zd a r√°csra)</div>
        <div class="trayHint">
          Egy feladat 3 helyes l√©p√©sb≈ël √°ll. Minden helyes lerak√°s ut√°n az √°llat r√∂gz√ºl a r√°cson, √©s j√∂n a k√∂vetkez≈ë utas√≠t√°s.
          Reset csak a feladat v√©g√©n van.
        </div>
        <div id="tray" class="tray"></div>
        <div id="status" class="status neutral">K√©szen √°ll.</div>
        <div id="progress" class="progress"></div>
      </div>
    </div>
  </div>

<script>
(() => {
  const GRID_N = 4;
  const STEPS_PER_ROUND = 3;

  // 10 √°llat (n√©v + t√°rgyeset + n√©vel≈ë)
  const entities = {
    bunny:   { id:"bunny",   nameHU:"nyuszi",   accHU:"nyuszit",    articleNom:"a",  articleAcc:"a",  emoji:"üê∞", pos:null },
    elephant:{ id:"elephant",nameHU:"elef√°nt",  accHU:"elef√°ntot",  articleNom:"az", articleAcc:"az", emoji:"üêò", pos:null },
    lion:    { id:"lion",    nameHU:"oroszl√°n", accHU:"oroszl√°nt",  articleNom:"az", articleAcc:"az", emoji:"ü¶Å", pos:null },
    fox:     { id:"fox",     nameHU:"r√≥ka",     accHU:"r√≥k√°t",      articleNom:"a",  articleAcc:"a",  emoji:"ü¶ä", pos:null },
    panda:   { id:"panda",   nameHU:"panda",    accHU:"pand√°t",     articleNom:"a",  articleAcc:"a",  emoji:"üêº", pos:null },
    monkey:  { id:"monkey",  nameHU:"majom",    accHU:"majmot",     articleNom:"a",  articleAcc:"a",  emoji:"üêµ", pos:null },
    dog:     { id:"dog",     nameHU:"kutya",    accHU:"kuty√°t",     articleNom:"a",  articleAcc:"a",  emoji:"üê∂", pos:null },
    cat:     { id:"cat",     nameHU:"cica",     accHU:"cic√°t",      articleNom:"a",  articleAcc:"a",  emoji:"üê±", pos:null },
    frog:    { id:"frog",    nameHU:"b√©ka",     accHU:"b√©k√°t",      articleNom:"a",  articleAcc:"a",  emoji:"üê∏", pos:null },
    bear:    { id:"bear",    nameHU:"medve",    accHU:"medv√©t",     articleNom:"a",  articleAcc:"a",  emoji:"üêª", pos:null }
  };

  // Rel√°ci√≥k ‚Äì a referencia √°llatra hivatkozunk
  const relations = {
    above: { dx: 0, dy: -1, phrase: (ref) => `${ref.articleNom} ${ref.nameHU} f√∂l√©` },
    below: { dx: 0, dy:  1, phrase: (ref) => `${ref.articleNom} ${ref.nameHU} al√°` },
    left:  { dx:-1, dy:  0, phrase: (ref) => `${ref.articleNom} ${ref.nameHU} bal oldal√°ra` },
    right: { dx: 1, dy:  0, phrase: (ref) => `${ref.articleNom} ${ref.nameHU} jobb oldal√°ra` }
  };

  const gridEl = document.getElementById("grid");
  const trayEl = document.getElementById("tray");
  const taskTextEl = document.getElementById("taskText");
  const statusEl = document.getElementById("status");
  const progressEl = document.getElementById("progress");
  const btnNew = document.getElementById("btnNew");
  const btnRepeat = document.getElementById("btnRepeat");

  let cellEls = [];
  let lastSpokenText = "";
  let dragging = null;     // { id, el, offsetX, offsetY, fromTray:boolean }

  // Round state
  let round = null;
  // round = {
  //   refId, refPos, stepIndex (0..2),
  //   trayIds, currentStep: { movingId, relKey, target:{r,c}, textHU },
  //   usedIds: Set
  // }

  function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

  function setStatus(type, text){
    statusEl.classList.remove("ok","bad","neutral");
    statusEl.classList.add(type);
    statusEl.textContent = text;
  }

  function setProgress(){
    if (!round){
      progressEl.textContent = "";
      return;
    }
    progressEl.textContent = `L√©p√©s: ${round.stepIndex + 1} / ${STEPS_PER_ROUND}`;
  }

  function clearCellHighlights(){
    for (let r=0; r<GRID_N; r++){
      for (let c=0; c<GRID_N; c++){
        cellEls[r][c].classList.remove("ok","bad");
      }
    }
  }

  function cellAtPoint(clientX, clientY){
    for (let r=0; r<GRID_N; r++){
      for (let c=0; c<GRID_N; c++){
        const el = cellEls[r][c];
        const rect = el.getBoundingClientRect();
        if (clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom){
          return { r, c, el };
        }
      }
    }
    return null;
  }

  function isOccupied(r, c){
    for (const e of Object.values(entities)){
      if (e.pos && e.pos.r === r && e.pos.c === c) return true;
    }
    return false;
  }

  function resetAllPositions(){
    for (const e of Object.values(entities)){
      e.pos = null;
    }
  }

  function cleanupFloatingDrag(){
    if (dragging && dragging.el){
      try{ dragging.el.remove(); }catch(_){}
    }
    dragging = null;
    document.querySelectorAll(".piece.dragging").forEach(el => el.remove());
  }

  function speakHU(text){
    lastSpokenText = text;
    if (!("speechSynthesis" in window)) return;

    window.speechSynthesis.cancel();

    const u = new SpeechSynthesisUtterance(text);
    u.lang = "hu-HU";
    u.rate = 0.95;
    u.pitch = 1.0;

    const voices = window.speechSynthesis.getVoices?.() || [];
    const huVoice = voices.find(v => (v.lang || "").toLowerCase().startsWith("hu"));
    if (huVoice) u.voice = huVoice;

    window.speechSynthesis.speak(u);
  }

  if ("speechSynthesis" in window) {
    window.speechSynthesis.onvoiceschanged = () => {};
  }

  function randomInt(a, b){ return Math.floor(Math.random() * (b - a + 1)) + a; }

  function pickRandom(arr){ return arr[randomInt(0, arr.length - 1)]; }

  function pickNWithoutReplacement(arr, n){
    const copy = arr.slice();
    for (let i = copy.length - 1; i > 0; i--){
      const j = Math.floor(Math.random() * (i + 1));
      [copy[i], copy[j]] = [copy[j], copy[i]];
    }
    return copy.slice(0, n);
  }

  function chooseRandomRelationKey(){
    const keys = Object.keys(relations);
    return pickRandom(keys);
  }

  function placeReferenceSoTargetFits(relKey){
    const rel = relations[relKey];
    const minR = clamp(0 - rel.dy, 0, GRID_N-1);
    const maxR = clamp((GRID_N-1) - rel.dy, 0, GRID_N-1);
    const minC = clamp(0 - rel.dx, 0, GRID_N-1);
    const maxC = clamp((GRID_N-1) - rel.dx, 0, GRID_N-1);
    return { r: randomInt(minR, maxR), c: randomInt(minC, maxC) };
  }

  function buildGrid(){
    gridEl.innerHTML = "";
    cellEls = Array.from({length: GRID_N}, () => Array.from({length: GRID_N}, () => null));
    for (let r=0; r<GRID_N; r++){
      for (let c=0; c<GRID_N; c++){
        const cell = document.createElement("div");
        cell.className = "cell";
        gridEl.appendChild(cell);
        cellEls[r][c] = cell;
      }
    }
  }

  function createPieceElement(entity, draggable){
    const el = document.createElement("div");
    el.className = "piece" + (draggable ? "" : " fixed");
    el.dataset.id = entity.id;
    el.textContent = entity.emoji;
    el.setAttribute("role","img");
    el.setAttribute("aria-label", entity.nameHU);

    if (draggable){
      el.addEventListener("pointerdown", onPointerDown, {passive:false});
    }
    return el;
  }

  function renderAll(){
    // grid clear
    for (let r=0; r<GRID_N; r++){
      for (let c=0; c<GRID_N; c++){
        const cell = cellEls[r][c];
        [...cell.querySelectorAll(".piece")].forEach(p => p.remove());
      }
    }

    // grid pieces (mind fix a r√°cson: referencia + m√°r helyesen lerakottak)
    for (const e of Object.values(entities)){
      if (e.pos){
        const cell = cellEls[e.pos.r][e.pos.c];
        const piece = createPieceElement(e, false);
        cell.appendChild(piece);
      }
    }

    // tray: mindig 3 √°llat, de ahogy helyesen lerakja, elt≈±nik a t√°lc√°r√≥l
    trayEl.innerHTML = "";
    if (round){
      for (const id of round.trayIds){
        const e = entities[id];
        if (e.pos) continue; // m√°r lerakva => ne legyen a t√°lc√°n
        const slot = document.createElement("div");
        slot.className = "traySlot";
        const piece = createPieceElement(e, true);
        slot.appendChild(piece);
        trayEl.appendChild(slot);
      }
    }
  }

  function makeNewRound(){
    resetAllPositions();
    cleanupFloatingDrag();
    clearCellHighlights();

    const allIds = Object.keys(entities);

    // referencia: 1 v√©letlen √°llat
    const refId = pickRandom(allIds);

    // t√°lca: 3 v√©letlen, a referenci√°t√≥l k√ºl√∂nb√∂z≈ë
    const remaining = allIds.filter(id => id !== refId);
    const trayIds = pickNWithoutReplacement(remaining, 3);

    // referencia poz√≠ci√≥: majd az els≈ë l√©p√©s rel√°ci√≥j√°hoz igaz√≠tjuk (hogy mindig legyen valid c√©l)
    // ez√©rt itt m√©g nem tessz√ºk le; a l√©p√©s gener√°l√°s d√∂nti el a refPos-t.

    round = {
      refId,
      refPos: null,
      stepIndex: 0,
      trayIds,
      currentStep: null
    };

    // els≈ë l√©p√©s
    nextStep(true);
  }

  function generateStep(isFirstStep){
    // Melyik √°llatot kell most mozgatni? A t√°lc√°n l√©v≈ëk k√∂z√ºl, ami m√©g nincs lerakva.
    const candidates = round.trayIds.filter(id => !entities[id].pos);
    const movingId = pickRandom(candidates);

    const relKey = chooseRandomRelationKey();

    // Els≈ë l√©p√©sn√©l a referencia poz√≠ci√≥j√°t √∫gy v√°lasztjuk, hogy a c√©lmez≈ë biztosan r√°cson bel√ºl legyen.
    // K√©s≈ëbbi l√©p√©sn√©l a referencia m√°r fixen a r√°cson van, ez√©rt rel√°ci√≥t addig sorsoljuk,
    // am√≠g a c√©lmez≈ë r√°cson bel√ºl √©s √ºres (nem foglalt).
    if (isFirstStep){
      const refPos = placeReferenceSoTargetFits(relKey);
      round.refPos = refPos;
      entities[round.refId].pos = { ...refPos };
    }

    const refPos = entities[round.refId].pos;
    const ref = entities[round.refId];

    function computeTarget(key){
      const rel = relations[key];
      return { r: refPos.r + rel.dy, c: refPos.c + rel.dx };
    }

    let key = relKey;
    let target = computeTarget(key);

    // Ha nem els≈ë l√©p√©s: c√©lmez≈ë legyen r√°cson bel√ºl √âS √ºres
    if (!isFirstStep){
      let guard = 0;
      while (guard < 40){
        const rel = relations[key];
        const rr = refPos.r + rel.dy;
        const cc = refPos.c + rel.dx;
        const inside = rr >= 0 && rr < GRID_N && cc >= 0 && cc < GRID_N;
        if (inside && !isOccupied(rr, cc)){
          target = { r: rr, c: cc };
          break;
        }
        key = chooseRandomRelationKey();
        guard++;
      }
    } else {
      // els≈ë l√©p√©sn√©l m√©g csak a referencia foglalhat
      // ha c√©l √©pp foglalt lenne (nem k√©ne), de biztosra megy√ºnk:
      if (isOccupied(target.r, target.c)){
        // √∫j rel/poz
        let guard = 0;
        while (guard < 40){
          const k2 = chooseRandomRelationKey();
          const rp2 = placeReferenceSoTargetFits(k2);
          round.refPos = rp2;
          entities[round.refId].pos = { ...rp2 };
          const t2 = { r: rp2.r + relations[k2].dy, c: rp2.c + relations[k2].dx };
          if (!isOccupied(t2.r, t2.c)){
            key = k2;
            target = t2;
            break;
          }
          guard++;
        }
      }
    }

    const moving = entities[movingId];
    const text = `Tedd ${moving.articleAcc} ${moving.accHU} ${relations[key].phrase(ref)}.`;

    return { movingId, relKey: key, target, textHU: text };
  }

  function nextStep(isFirstStep){
    round.currentStep = generateStep(isFirstStep);
    taskTextEl.textContent = round.currentStep.textHU;
    setStatus("neutral", "H√∫zd a megfelel≈ë √°llatot a megfelel≈ë mez≈ëre.");
    setProgress();
    renderAll();
    speakHU(round.currentStep.textHU);
  }

  function finishRound(){
    setStatus("ok", "Gratul√°lok, mindet j√≥l megoldottad!");
    speakHU("Gratul√°lok, mindet j√≥l megoldottad.");

    // V√©gs≈ë reset a gratul√°ci√≥ ut√°n, majd √∫j feladat automatikusan
    setTimeout(() => {
      makeNewRound();
    }, 1300);
  }

  function repeatTaskAudio(){
    if (lastSpokenText) speakHU(lastSpokenText);
    else if (round && round.currentStep) speakHU(round.currentStep.textHU);
  }

  function onPointerDown(ev){
    ev.preventDefault();
    if (!round || !round.currentStep) return;

    const id = ev.currentTarget.dataset.id;

    // csak t√°lc√°s √°llatok h√∫zhat√≥k (√©s csak azok, amik m√©g nem ker√ºltek le)
    if (!round.trayIds.includes(id)) return;
    if (entities[id].pos) return;

    const el = ev.currentTarget;
    const rect = el.getBoundingClientRect();
    const offsetX = ev.clientX - rect.left;
    const offsetY = ev.clientY - rect.top;

    dragging = { id, el, offsetX, offsetY };
    el.classList.add("dragging");
    el.style.position = "fixed";
    el.style.left = (ev.clientX - offsetX) + "px";
    el.style.top  = (ev.clientY - offsetY) + "px";
    document.body.appendChild(el);

    el.setPointerCapture(ev.pointerId);
    el.addEventListener("pointermove", onPointerMove, {passive:false});
    el.addEventListener("pointerup", onPointerUp, {passive:false});
    el.addEventListener("pointercancel", onPointerUp, {passive:false});
  }

  function onPointerMove(ev){
    if (!dragging) return;
    ev.preventDefault();
    const { el, offsetX, offsetY } = dragging;
    el.style.left = (ev.clientX - offsetX) + "px";
    el.style.top  = (ev.clientY - offsetY) + "px";
  }

  function onPointerUp(ev){
    if (!dragging || !round || !round.currentStep) return;
    ev.preventDefault();

    const { id, el } = dragging;

    try{
      el.classList.remove("dragging");
      el.releasePointerCapture?.(ev.pointerId);
      el.removeEventListener("pointermove", onPointerMove);
      el.removeEventListener("pointerup", onPointerUp);
      el.removeEventListener("pointercancel", onPointerUp);
      el.remove();
    }catch(_){}
    dragging = null;

    const hit = cellAtPoint(ev.clientX, ev.clientY);
    if (!hit){
      clearCellHighlights();
      setStatus("bad", "Nem a r√°csra tetted.");
      speakHU("Nem a r√°csra tetted.");
      renderAll(); // visszaker√ºl a t√°lc√°n, mert nem kap pos-t
      return;
    }

    const { r, c } = hit;

    // foglalt mez≈ë (referencia vagy m√°r r√∂gz√≠tett √°llat)
    if (isOccupied(r, c)){
      clearCellHighlights();
      setStatus("bad", "Ez a mez≈ë foglalt.");
      speakHU("Ez a mez≈ë foglalt.");
      renderAll();
      return;
    }

    // ellen≈ërz√©s
    const step = round.currentStep;
    const correctAnimal = (id === step.movingId);
    const correctCell = (r === step.target.r && c === step.target.c);
    const correct = correctAnimal && correctCell;

    clearCellHighlights();

    if (!correct){
      cellEls[r][c].classList.add("bad");
      setStatus("bad", "Nem j√≥ helyre tetted.");
      speakHU("Nem j√≥ helyre tetted.");
      renderAll(); // t√°lc√°n marad
      return;
    }

    // helyes: r√∂gz√≠tj√ºk a r√°csra
    entities[id].pos = { r, c };
    renderAll();

    cellEls[r][c].classList.add("ok");
    setStatus("ok", "√úgyes vagy!");
    speakHU("√úgyes vagy!");

    // k√∂vetkez≈ë l√©p√©s / befejez√©s
    round.stepIndex++;

    if (round.stepIndex >= STEPS_PER_ROUND){
      setProgress();
      setTimeout(() => finishRound(), 650);
      return;
    }

    // k√∂vetkez≈ë utas√≠t√°s (referencia m√°r fix)
    setTimeout(() => {
      nextStep(false);
    }, 650);
  }

  btnNew.addEventListener("click", () => makeNewRound());
  btnRepeat.addEventListener("click", () => repeatTaskAudio());

  // Init
  buildGrid();
  setStatus("neutral", "Nyomd meg az ‚Äú√öj feladat‚Äù gombot.");
})();
</script>
</body>
</html>
