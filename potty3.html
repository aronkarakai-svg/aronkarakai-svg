<!doctype html>
<html lang="hu">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Körválasztós játék (3–6 kör) – 1 sor, reszponzív</title>
  <style>
    :root{
      --bg: #0b1020;
      --line: rgba(255,255,255,.14);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.72);
      --ok: rgba(92,255,156,.35);
      --bad: rgba(255,92,92,.35);

      /* Ezeket JS számolja újra */
      --hit: 96px;   /* tappolható doboz */
      --gap: 16px;   /* elemek közti tér */
    }

    *{ box-sizing: border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background: radial-gradient(1200px 600px at 30% 0%, #16224a 0%, var(--bg) 55%);
      color: var(--text);
    }

    .app{
      min-height: 100vh;
      display:flex;
      flex-direction: column;
      gap: 12px;
      padding: 14px;
      align-items: center;
    }

    .topbar{
      width: min(900px, 96vw);
      display:flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      background: rgba(255,255,255,.06);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 12px;
    }

    .task{
      display:flex;
      flex-direction: column;
      gap: 4px;
      min-width: 260px;
      flex: 1;
    }
    .task .title{ font-weight: 800; letter-spacing: .2px; }
    .task strong{ font-size: 16px; }
    .task small{ color: var(--muted); line-height: 1.2; }

    .controls{
      display:flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    button{
      appearance:none;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.08);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      font-weight: 700;
      font-size: 14px;
      cursor: pointer;
      user-select: none;
      touch-action: manipulation;
    }
    button:active{ transform: translateY(1px); }

    .card{
      width: min(900px, 96vw);
      background: rgba(255,255,255,.06);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 14px;
    }

    .rowWrap{
      display:flex;
      justify-content: center;
      align-items: center;
      min-height: 220px;
    }

    /* FONTOS: nowrap => soha nem lesz 2 sor */
    .row{
      display:flex;
      flex-wrap: nowrap;
      align-items: flex-end;
      justify-content: center;
      gap: var(--gap);
      padding: 18px 10px;
      border-radius: 14px;
      border: 1px dashed rgba(255,255,255,.18);
      background: rgba(0,0,0,.12);
      width: 100%;
      overflow: hidden;  /* nem engedjük átcsúszni */
    }

    /* tappolható felület (mindig elég nagy) */
    .dotHit{
      width: var(--hit);
      height: var(--hit);
      border-radius: 18px;
      display:flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      touch-action: none;
      cursor: pointer;
      position: relative;
      flex: 0 0 auto; /* ne zsugorodjon wrap miatt */
    }
    .dotHit:active{ transform: scale(0.985); }

    /* látható kör */
    .dot{
      border-radius: 999px;
      border: 2px solid rgba(255,255,255,.18);
      box-shadow: 0 12px 28px rgba(0,0,0,.35);
      position: relative;
    }

    .dotHit.ok{ outline: 6px solid var(--ok); outline-offset: 6px; }
    .dotHit.bad{ outline: 6px solid var(--bad); outline-offset: 6px; }

    .legend{
      margin-top: 10px;
      text-align: center;
      color: var(--muted);
      font-weight: 800;
      min-height: 22px;
    }
    .legend.ok{ color: rgba(160,255,200,.95); }
    .legend.bad{ color: rgba(255,160,160,.95); }
  </style>
</head>
<body>
  <div class="app">
    <div class="topbar">
      <div class="task">
        <div class="title">Körválasztós játék (3–6 kör)</div>
        <strong id="taskText">Nyomd meg az “Új feladat” gombot.</strong>
        <small>Hang alapú játék: koppints a megfelelő körre.</small>
      </div>
      <div class="controls">
        <button id="btnNew">Új feladat</button>
        <button id="btnRepeat">Ismételd a hangot</button>
      </div>
    </div>

    <div class="card">
      <div class="rowWrap">
        <div id="row" class="row" aria-label="Körök sora"></div>
      </div>
      <div id="status" class="legend">Készen áll.</div>
    </div>
  </div>

<script>
(() => {
  const rowEl = document.getElementById("row");
  const taskTextEl = document.getElementById("taskText");
  const statusEl = document.getElementById("status");
  const btnNew = document.getElementById("btnNew");
  const btnRepeat = document.getElementById("btnRepeat");

  const colorPool = [
    { key:"piros",   css:"#e53935" },
    { key:"zöld",    css:"#43a047" },
    { key:"kék",     css:"#1e88e5" },
    { key:"sárga",   css:"#fdd835" },
    { key:"lila",    css:"#8e24aa" },
    { key:"narancs", css:"#fb8c00" }
  ];

  // Méretfaktorok a látható körhöz a hit-dobozhoz képest (észrevehető különbség, de nem túl kicsi).
  const sizeFactors = [0.78, 0.90, 1.02, 1.15];

  let dots = [];      // [{id, idx, colorKey, colorCss, factor, sizePx}]
  let task = null;    // { type, textHU, answerId }
  let lastSpokenText = "";
  let locked = false;

  function setStatus(type, text){
    statusEl.classList.remove("ok","bad");
    if (type) statusEl.classList.add(type);
    statusEl.textContent = text;
  }

  function speakHU(text){
    lastSpokenText = text;
    if (!("speechSynthesis" in window)) return;

    window.speechSynthesis.cancel();
    const u = new SpeechSynthesisUtterance(text);
    u.lang = "hu-HU";
    u.rate = 0.95;
    u.pitch = 1.0;

    const voices = window.speechSynthesis.getVoices?.() || [];
    const huVoice = voices.find(v => (v.lang || "").toLowerCase().startsWith("hu"));
    if (huVoice) u.voice = huVoice;

    window.speechSynthesis.speak(u);
  }
  if ("speechSynthesis" in window) {
    window.speechSynthesis.onvoiceschanged = () => {};
  }

  function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
  function pickRandom(arr){ return arr[randInt(0, arr.length-1)]; }
  function shuffle(arr){
    const a = arr.slice();
    for (let i=a.length-1; i>0; i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  // Reszponzív kiosztás: a row szélességéből számoljuk a hit és gap értékeket,
  // hogy 3–6 elem biztosan 1 sorban elférjen.
  function applyResponsiveLayout(n){
    const rect = rowEl.getBoundingClientRect();
    const available = Math.max(320, rect.width - 20); // minimálisan is számolható

    // rés a teljes szélesség arányában, clampelve
    const gap = Math.max(10, Math.min(18, Math.floor(available * 0.02)));

    // hit = (available - gap*(n-1)) / n
    const rawHit = Math.floor((available - gap * (n - 1)) / n);

    // tabletbarát clamp: ne legyen túl kicsi, de ne is nőjön túl
    const hit = Math.max(78, Math.min(118, rawHit));

    document.documentElement.style.setProperty("--gap", gap + "px");
    document.documentElement.style.setProperty("--hit", hit + "px");

    // Látható kör méret: minimum 72px, maximum hit-8px
    const maxDot = Math.max(72, hit - 8);
    const minDot = Math.min(maxDot, 72);

    // kiosztjuk a dot-méreteket
    const factors = shuffle(sizeFactors.concat(sizeFactors)); // elég hosszú legyen
    for (let i=0; i<dots.length; i++){
      dots[i].factor = factors[i];
      const px = Math.floor(hit * dots[i].factor);
      dots[i].sizePx = Math.max(minDot, Math.min(maxDot, px));
    }
  }

  function buildDots(){
    const n = randInt(3, 6);

    const colors = shuffle(colorPool).concat(shuffle(colorPool));
    dots = [];
    for (let i=0; i<n; i++){
      const col = colors[i];
      dots.push({
        id: "d" + i,
        idx: i,
        colorKey: col.key,
        colorCss: col.css,
        factor: 1,
        sizePx: 80
      });
    }

    applyResponsiveLayout(n);
  }

  function renderDots(){
    rowEl.innerHTML = "";
    for (const d of dots){
      const hit = document.createElement("div");
      hit.className = "dotHit";
      hit.dataset.id = d.id;

      const dot = document.createElement("div");
      dot.className = "dot";
      dot.style.width = d.sizePx + "px";
      dot.style.height = d.sizePx + "px";
      dot.style.background = d.colorCss;

      hit.appendChild(dot);

      hit.addEventListener("pointerdown", (ev) => {
        ev.preventDefault();
        if (locked || !task) return;
        handlePick(d.id);
      }, {passive:false});

      rowEl.appendChild(hit);
    }
  }

  function clearMarks(){
    rowEl.querySelectorAll(".dotHit").forEach(el => el.classList.remove("ok","bad"));
  }

  function markHit(id, cls){
    const el = rowEl.querySelector(`.dotHit[data-id="${id}"]`);
    if (el) el.classList.add(cls);
  }

  function nthTextHU(n){
    const map = {1:"elsőt",2:"másodikat",3:"harmadikat",4:"negyediket",5:"ötödiket",6:"hatodikat"};
    return map[n] || (n + ".-at");
  }

  function makeTask(){
    const n = dots.length;
    const kinds = [];

    kinds.push("leftmost", "rightmost");
    if (n % 2 === 1) kinds.push("middle");

    kinds.push("fromLeftN");
    if (n >= 4) kinds.push("fromRightN");

    kinds.push("color");
    kinds.push("largest", "smallest");

    const type = pickRandom(kinds);

    if (type === "leftmost"){
      return { type, answerId: dots[0].id, textHU: "Válaszd ki a bal oldalit." };
    }
    if (type === "rightmost"){
      return { type, answerId: dots[n-1].id, textHU: "Válaszd ki a jobb oldalit." };
    }
    if (type === "middle"){
      return { type, answerId: dots[(n-1)/2].id, textHU: "Válaszd ki a középsőt." };
    }
    if (type === "fromLeftN"){
      const k = randInt(1, n);
      return { type, answerId: dots[k-1].id, textHU: `Válaszd ki a balról a ${nthTextHU(k)}.` };
    }
    if (type === "fromRightN"){
      const k = randInt(1, n);
      return { type, answerId: dots[n-k].id, textHU: `Válaszd ki a jobbról a ${nthTextHU(k)}.` };
    }
    if (type === "color"){
      const ans = pickRandom(dots);
      return { type, answerId: ans.id, textHU: `Válaszd ki a ${ans.colorKey}at.` };
    }
    if (type === "largest"){
      const ans = dots.slice().sort((a,b)=>b.sizePx-a.sizePx)[0];
      return { type, answerId: ans.id, textHU: "Válaszd ki a legnagyobbat." };
    }
    if (type === "smallest"){
      const ans = dots.slice().sort((a,b)=>a.sizePx-b.sizePx)[0];
      return { type, answerId: ans.id, textHU: "Válaszd ki a legkisebbet." };
    }

    return { type:"leftmost", answerId: dots[0].id, textHU: "Válaszd ki a bal oldalit." };
  }

  function startNew(){
    locked = false;
    clearMarks();
    setStatus("", "Készen áll.");

    buildDots();
    renderDots();

    task = makeTask();
    taskTextEl.textContent = task.textHU;
    setStatus("", "Koppints a megfelelő körre.");
    speakHU(task.textHU);
  }

  function handlePick(pickedId){
    locked = true;
    clearMarks();

    const correct = pickedId === task.answerId;

    if (correct){
      markHit(pickedId, "ok");
      setStatus("ok", "Ügyes vagy!");
      speakHU("Ügyes vagy!");
    } else {
      markHit(pickedId, "bad");
      setStatus("bad", "Nem jó.");
      speakHU("Nem jó.");
    }

    setTimeout(() => startNew(), 900);
  }

  // Resizing: újraszámoljuk a hit/gap és látható méreteket, de megtartjuk az aktuális feladatot
  function relayoutOnly(){
    if (!dots.length) return;
    applyResponsiveLayout(dots.length);
    // csak a méreteket frissítjük a DOM-ban
    rowEl.querySelectorAll(".dotHit").forEach((hitEl, i) => {
      const dotEl = hitEl.querySelector(".dot");
      if (!dotEl || !dots[i]) return;
      dotEl.style.width = dots[i].sizePx + "px";
      dotEl.style.height = dots[i].sizePx + "px";
    });
  }

  btnNew.addEventListener("click", () => startNew());
  btnRepeat.addEventListener("click", () => {
    if (lastSpokenText) speakHU(lastSpokenText);
    else if (task) speakHU(task.textHU);
  });

  window.addEventListener("resize", () => {
    // kis késleltetés a stabil méréshez (pl. orientációváltás)
    clearTimeout(window.__rl_t);
    window.__rl_t = setTimeout(relayoutOnly, 50);
  });

  setStatus("", "Nyomd meg az “Új feladat” gombot.");
})();
</script>
</body>
</html>
