<!doctype html>
<html lang="hu">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ir√°nyok j√°t√©k - 3x3</title>
  <style>
    :root{
      --gap: 10px;
      --cell: 90px;
      --radius: 12px;
      --panel: 320px;
      --bg: #0b1020;
      --line: rgba(255,255,255,.14);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.72);
      --ok: rgba(92, 255, 156, .35);
      --bad: rgba(255, 92, 92, .35);
    }

    *{ box-sizing: border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background: radial-gradient(1200px 600px at 30% 0%, #16224a 0%, var(--bg) 55%);
      color: var(--text);
    }

    .app{
      min-height: 100vh;
      display:flex;
      flex-direction: column;
      padding: 14px;
      gap: 12px;
    }

    .topbar{
      display:flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      background: rgba(255,255,255,.06);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding: 12px 12px;
    }

    .title{
      font-weight: 700;
      letter-spacing: .2px;
    }

    .task{
      display:flex;
      flex-direction: column;
      gap: 4px;
      min-width: 260px;
      flex: 1;
    }

    .task strong{ font-size: 16px; }
    .task small{
      color: var(--muted);
      line-height: 1.2;
    }

    .controls{
      display:flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    button{
      appearance:none;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.08);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      font-weight: 650;
      font-size: 14px;
      cursor: pointer;
      user-select: none;
      touch-action: manipulation;
    }
    button:active{ transform: translateY(1px); }

    .main{
      display:flex;
      gap: 12px;
      flex: 1;
      align-items: stretch;
    }

    .boardCard, .trayCard{
      background: rgba(255,255,255,.06);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding: 12px;
    }

    .boardCard{
      flex: 1;
      display:flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }

    .trayCard{
      width: min(var(--panel), 92vw);
      display:flex;
      flex-direction: column;
      gap: 10px;
    }

    .trayTitle{
      font-weight: 700;
      color: var(--muted);
    }

    .layoutHint{
      color: var(--muted);
      font-size: 13px;
      line-height: 1.25;
    }

    @media (max-width: 860px){
      .main{ flex-direction: column; }
      .trayCard{ width: 100%; }
    }

    .grid{
      display:grid;
      grid-template-columns: repeat(3, var(--cell));
      grid-template-rows: repeat(3, var(--cell));
      gap: var(--gap);
      padding: var(--gap);
      border-radius: 16px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.16);
      touch-action: none;
      user-select: none;
      position: relative;
    }

    .cell{
      width: var(--cell);
      height: var(--cell);
      border-radius: 14px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      position: relative;
    }

    .cell.ok{ outline: 4px solid var(--ok); }
    .cell.bad{ outline: 4px solid var(--bad); }

    .piece{
      width: calc(var(--cell) - 10px);
      height: calc(var(--cell) - 10px);
      border-radius: 16px;
      display:flex;
      align-items: center;
      justify-content: center;
      font-size: 42px;
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.18);
      box-shadow: 0 10px 22px rgba(0,0,0,.32);
      position: absolute;
      left: 5px;
      top: 5px;
      touch-action: none;
      user-select: none;
    }

    .piece.fixed{
      background: rgba(255,255,255,.08);
      box-shadow: none;
      border-style: dashed;
      opacity: .95;
    }

    .piece.dragging{
      transform: scale(1.06);
      z-index: 999;
    }

    .tray{
      display:flex;
      flex-wrap: wrap;
      gap: 10px;
      padding: 6px 2px 2px 2px;
      min-height: 90px;
      border-radius: 14px;
      border: 1px dashed rgba(255,255,255,.18);
      background: rgba(0,0,0,.12);
      position: relative;
    }

    .traySlot{
      width: 86px;
      height: 86px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      display:flex;
      align-items: center;
      justify-content:center;
      position: relative;
    }

    .traySlot .piece{
      position: static;
      width: 74px;
      height: 74px;
      font-size: 44px;
    }

    .status{
      font-weight: 700;
      min-height: 22px;
    }
    .status.ok{ color: rgba(160,255,200,.95); }
    .status.bad{ color: rgba(255,160,160,.95); }
    .status.neutral{ color: var(--muted); }
  </style>
</head>
<body>
  <div class="app">
    <div class="topbar">
      <div class="task">
        <div class="title">Ir√°nyok gyakorl√°sa (3√ó3)</div>
        <strong id="taskText">Nyomd meg az ‚Äú√öj feladat‚Äù gombot.</strong>
        <small id="taskSub">A besz√©d lej√°tsz√°s√°hoz az els≈ë gombnyom√°s ut√°n a b√∂ng√©sz≈ë enged√©lyezi a hangot.</small>
      </div>
      <div class="controls">
        <button id="btnNew">√öj feladat</button>
        <button id="btnRepeat">Ism√©teld a hangot</button>
      </div>
    </div>

    <div class="main">
      <div class="boardCard">
        <div id="grid" class="grid" aria-label="3x3 r√°cs"></div>
      </div>

      <div class="trayCard">
        <div class="trayTitle">T√°lca (h√∫zd a r√°csra)</div>
        <div class="layoutHint">
          H√∫zd az elef√°ntot a r√°cs egy mez≈ëj√©re. A rendszer azonnal ellen≈ëriz, majd minden esetben resetel √©s ad egy √∫j feladatot.
        </div>
        <div id="tray" class="tray"></div>
        <div id="status" class="status neutral">K√©szen √°ll.</div>
      </div>
    </div>
  </div>

<script>
(() => {
  const GRID_N = 3;

  const entities = {
    bunny:    { id: "bunny",    nameHU: "nyuszi",  emoji: "üê∞", fixed: true,  pos: null },
    elephant: { id: "elephant", nameHU: "elef√°nt", emoji: "üêò", fixed: false, pos: null }
  };

  // "a nyuszit√≥l jobbra/balra/f√∂l√©/al√°"
  const relations = {
    above: { dx: 0, dy: -1, hu: "f√∂l√©" },
    below: { dx: 0, dy:  1, hu: "al√°" },
    left:  { dx: -1, dy: 0, hu: "balra" },
    right: { dx:  1, dy: 0, hu: "jobbra" }
  };

  const gridEl = document.getElementById("grid");
  const trayEl = document.getElementById("tray");
  const taskTextEl = document.getElementById("taskText");
  const statusEl = document.getElementById("status");
  const btnNew = document.getElementById("btnNew");
  const btnRepeat = document.getElementById("btnRepeat");

  let cellEls = [];
  let currentTask = null;
  let lastSpokenText = "";

  let dragging = null; // { id, el, offsetX, offsetY }

  function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

  function setStatus(type, text){
    statusEl.classList.remove("ok","bad","neutral");
    statusEl.classList.add(type);
    statusEl.textContent = text;
  }

  function clearCellHighlights(){
    for (let r=0; r<GRID_N; r++){
      for (let c=0; c<GRID_N; c++){
        cellEls[r][c].classList.remove("ok","bad");
      }
    }
  }

  function cellAtPoint(clientX, clientY){
    for (let r=0; r<GRID_N; r++){
      for (let c=0; c<GRID_N; c++){
        const el = cellEls[r][c];
        const rect = el.getBoundingClientRect();
        if (clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom){
          return { r, c, el };
        }
      }
    }
    return null;
  }

  function isOccupied(r, c){
    for (const e of Object.values(entities)){
      if (e.pos && e.pos.r === r && e.pos.c === c) return true;
    }
    return false;
  }

  function getEntityById(id){
    return Object.values(entities).find(e => e.id === id);
  }

  function speakHU(text){
    lastSpokenText = text;
    if (!("speechSynthesis" in window)) return;

    window.speechSynthesis.cancel();

    const u = new SpeechSynthesisUtterance(text);
    u.lang = "hu-HU";
    u.rate = 0.95;
    u.pitch = 1.0;

    const voices = window.speechSynthesis.getVoices?.() || [];
    const huVoice = voices.find(v => (v.lang || "").toLowerCase().startsWith("hu"));
    if (huVoice) u.voice = huVoice;

    window.speechSynthesis.speak(u);
  }

  if ("speechSynthesis" in window) {
    window.speechSynthesis.onvoiceschanged = () => {};
  }

  function buildGrid(){
    gridEl.innerHTML = "";
    cellEls = Array.from({length: GRID_N}, () => Array.from({length: GRID_N}, () => null));
    for (let r=0; r<GRID_N; r++){
      for (let c=0; c<GRID_N; c++){
        const cell = document.createElement("div");
        cell.className = "cell";
        gridEl.appendChild(cell);
        cellEls[r][c] = cell;
      }
    }
  }

  function createPieceElement(entity){
    const el = document.createElement("div");
    el.className = "piece" + (entity.fixed ? " fixed" : "");
    el.dataset.id = entity.id;
    el.textContent = entity.emoji;
    el.setAttribute("role","img");
    el.setAttribute("aria-label", entity.nameHU);

    if (!entity.fixed){
      el.addEventListener("pointerdown", onPointerDown, {passive:false});
    }
    return el;
  }

  function renderAll(){
    // clear pieces from grid
    for (let r=0; r<GRID_N; r++){
      for (let c=0; c<GRID_N; c++){
        const cell = cellEls[r][c];
        [...cell.querySelectorAll(".piece")].forEach(p => p.remove());
      }
    }

    // fixed pieces
    for (const e of Object.values(entities)){
      if (e.pos){
        const cell = cellEls[e.pos.r][e.pos.c];
        const piece = createPieceElement(e);
        cell.appendChild(piece);
      }
    }

    // tray
    trayEl.innerHTML = "";
    for (const e of Object.values(entities)){
      if (!e.fixed && !e.pos){
        const slot = document.createElement("div");
        slot.className = "traySlot";
        const piece = createPieceElement(e);
        slot.appendChild(piece);
        trayEl.appendChild(slot);
      }
    }
  }

  function randomInt(a, b){ return Math.floor(Math.random() * (b - a + 1)) + a; }

  function chooseRandomRelationKey(){
    const keys = Object.keys(relations);
    return keys[randomInt(0, keys.length - 1)];
  }

  function placeReferenceSoTargetFits(relKey){
    const rel = relations[relKey];
    const minR = clamp(0 - rel.dy, 0, GRID_N-1);
    const maxR = clamp((GRID_N-1) - rel.dy, 0, GRID_N-1);
    const minC = clamp(0 - rel.dx, 0, GRID_N-1);
    const maxC = clamp((GRID_N-1) - rel.dx, 0, GRID_N-1);

    const r = randomInt(minR, maxR);
    const c = randomInt(minC, maxC);
    entities.bunny.pos = { r, c };
  }

  function makeTask(){
    const movingId = "elephant";
    const refId = "bunny";
    const relKey = chooseRandomRelationKey();

    placeReferenceSoTargetFits(relKey);

    const refPos = entities[refId].pos;
    const rel = relations[relKey];
    const target = { r: refPos.r + rel.dy, c: refPos.c + rel.dx };

    const moving = entities[movingId];
    const ref = entities[refId];

    const text = `Tedd az ${moving.nameHU}ot a ${ref.nameHU}t√≥l ${rel.hu}.`;
    return { movingId, refId, relKey, target, textHU: text };
  }

  function hardResetAndNextTask(delayMs){
    setTimeout(() => {
      clearCellHighlights();
      // reset pieces
      entities.elephant.pos = null;
      // next task
      currentTask = makeTask();
      taskTextEl.textContent = currentTask.textHU;
      renderAll();
      setStatus("neutral", "H√∫zd az elef√°ntot egy mez≈ëre.");
      speakHU(currentTask.textHU);
    }, delayMs);
  }

  function startNewTask(){
    // Start immediately as a "reset + new task"
    hardResetAndNextTask(0);
  }

  function repeatTaskAudio(){
    if (lastSpokenText) speakHU(lastSpokenText);
    else if (currentTask) speakHU(currentTask.textHU);
  }

  function onPointerDown(ev){
    ev.preventDefault();

    const id = ev.currentTarget.dataset.id;
    const entity = getEntityById(id);
    if (!entity || entity.fixed) return;

    const el = ev.currentTarget;

    const rect = el.getBoundingClientRect();
    const offsetX = ev.clientX - rect.left;
    const offsetY = ev.clientY - rect.top;

    dragging = { id, el, offsetX, offsetY };
    el.classList.add("dragging");

    el.style.position = "fixed";
    el.style.left = (ev.clientX - offsetX) + "px";
    el.style.top  = (ev.clientY - offsetY) + "px";
    document.body.appendChild(el);

    el.setPointerCapture(ev.pointerId);
    el.addEventListener("pointermove", onPointerMove, {passive:false});
    el.addEventListener("pointerup", onPointerUp, {passive:false});
    el.addEventListener("pointercancel", onPointerUp, {passive:false});
  }

  function onPointerMove(ev){
    if (!dragging) return;
    ev.preventDefault();

    const { el, offsetX, offsetY } = dragging;
    el.style.left = (ev.clientX - offsetX) + "px";
    el.style.top  = (ev.clientY - offsetY) + "px";
  }

  function restoreToTray(id){
    const entity = getEntityById(id);
    entity.pos = null;
    renderAll();
  }

  function placeOnCell(id, r, c){
    const entity = getEntityById(id);
    entity.pos = { r, c };
    renderAll();
  }

  function onPointerUp(ev){
    if (!dragging) return;
    ev.preventDefault();

    const { id, el } = dragging;

    el.classList.remove("dragging");
    el.releasePointerCapture?.(ev.pointerId);
    el.removeEventListener("pointermove", onPointerMove);
    el.removeEventListener("pointerup", onPointerUp);
    el.removeEventListener("pointercancel", onPointerUp);

    const hit = cellAtPoint(ev.clientX, ev.clientY);

    // If dropped outside: treat as incorrect attempt and reset + next
    if (!hit){
      restoreToTray(id);
      clearCellHighlights();
      setStatus("bad", "Nem a r√°csra tetted.");
      speakHU("Nem a r√°csra tetted.");
      dragging = null;
      hardResetAndNextTask(800);
      return;
    }

    const { r, c } = hit;

    if (isOccupied(r, c)){
      restoreToTray(id);
      clearCellHighlights();
      setStatus("bad", "Ez a mez≈ë foglalt.");
      speakHU("Ez a mez≈ë foglalt.");
      dragging = null;
      hardResetAndNextTask(800);
      return;
    }

    placeOnCell(id, r, c);

    if (currentTask && id === currentTask.movingId){
      const t = currentTask.target;
      const correct = (r === t.r && c === t.c);

      clearCellHighlights();

      if (correct){
        cellEls[r][c].classList.add("ok");  // optional visual feedback
        setStatus("ok", "√úgyes vagy!");
        speakHU("√úgyes vagy!");
      } else {
        cellEls[r][c].classList.add("bad"); // optional visual feedback
        setStatus("bad", "Nem j√≥ helyre tetted.");
        speakHU("Nem j√≥ helyre tetted.");
      }

      // Always reset after any drop (correct or incorrect)
      dragging = null;
      hardResetAndNextTask(900);
      return;
    }

    dragging = null;
    hardResetAndNextTask(900);
  }

  btnNew.addEventListener("click", () => startNewTask());
  btnRepeat.addEventListener("click", () => repeatTaskAudio());

  // Init
  buildGrid();
  entities.bunny.pos = { r: 1, c: 1 };
  entities.elephant.pos = null;
  renderAll();

})();
</script>
</body>
</html>